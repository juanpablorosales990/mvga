generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

// ============================================================================
// User & Authentication
// ============================================================================

model User {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  email         String?  @unique
  displayName   String?
  username      String?  @unique
  role          String   @default("USER") // USER | ADMIN
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  stakes        Stake[]
  stakingClaims StakingClaim[]
  offers        P2POffer[]     @relation("SellerOffers")
  buyerTrades   P2PTrade[]     @relation("BuyerTrades")
  sellerTrades  P2PTrade[]     @relation("SellerTrades")
  reputation    UserReputation?
  votes         Vote[]
  kyc           UserKyc?

  @@index([walletAddress])
}

// ============================================================================
// KYC Verification (Sumsub)
// ============================================================================

model UserKyc {
  id              String    @id @default(uuid())
  userId          String    @unique
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  status          KycStatus @default(UNVERIFIED)
  provider        String    @default("SUMSUB")
  externalId      String?
  tier            Int       @default(0)
  rejectionReason String?
  verifiedAt      DateTime?
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([userId])
  @@index([status])
}

enum KycStatus {
  UNVERIFIED
  PENDING
  APPROVED
  REJECTED
  EXPIRED
}

model UserReputation {
  id              String @id @default(uuid())
  userId          String @unique
  user            User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  totalTrades     Int    @default(0)
  completedTrades Int    @default(0)
  disputesWon     Int    @default(0)
  disputesLost    Int    @default(0)
  rating          Float  @default(5.0)
  avgResponseTime Int    @default(0) // in minutes

  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([rating])
}

// ============================================================================
// Staking
// ============================================================================

model Stake {
  id          String    @id @default(uuid())
  userId      String
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  amount      BigInt    // Amount in smallest unit (lamports)
  lockPeriod  Int       // Lock period in days (0, 30, 90, 180)
  lockedUntil DateTime?

  stakeTx     String?   @unique // Solana transaction signature
  unstakeTx   String?   @unique // Solana transaction signature when unstaked
  autoCompound Boolean  @default(false) // Auto-reinvest rewards

  status        StakeStatus @default(ACTIVE)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  unstakedAt    DateTime?
  lastClaimedAt DateTime?

  @@index([userId])
  @@index([status])
  @@index([status, createdAt])
}

enum StakeStatus {
  ACTIVE
  UNSTAKING
  UNSTAKED
}

// ============================================================================
// P2P Exchange
// ============================================================================

model P2POffer {
  id                  String   @id @default(uuid())
  sellerId            String
  seller              User     @relation("SellerOffers", fields: [sellerId], references: [id], onDelete: Cascade)

  type                P2POfferType  // BUY or SELL crypto
  cryptoAmount        BigInt        // Total amount in smallest unit
  availableAmount     BigInt        // Remaining amount
  cryptoCurrency      String        // USDC, MVGA, etc.

  paymentMethod       PaymentMethod
  paymentInstructions String?

  rate                Float         // Exchange rate (1.0 = market rate)
  minAmount           BigInt        // Min trade amount in USD cents
  maxAmount           BigInt        // Max trade amount in USD cents

  status              P2POfferStatus @default(ACTIVE)
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt

  trades              P2PTrade[]

  @@index([sellerId])
  @@index([status])
  @@index([cryptoCurrency])
  @@index([paymentMethod])
}

enum P2POfferType {
  BUY
  SELL
}

enum PaymentMethod {
  ZELLE
  VENMO
  PAYPAL
  BANK_TRANSFER
  PAGO_MOVIL
  BINANCE_PAY
}

enum P2POfferStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

model P2PTrade {
  id           String   @id @default(uuid())
  offerId      String
  offer        P2POffer @relation(fields: [offerId], references: [id], onDelete: Restrict)

  buyerId      String
  buyer        User     @relation("BuyerTrades", fields: [buyerId], references: [id])
  sellerId     String
  seller       User     @relation("SellerTrades", fields: [sellerId], references: [id])

  amount       BigInt   // Trade amount in USD cents
  cryptoAmount BigInt   // Crypto amount in smallest unit

  status       P2PTradeStatus @default(PENDING)
  escrowTx     String?   @unique // Solana tx locking funds
  releaseTx    String?   @unique // Solana tx releasing funds

  disputeReason String?
  disputeEvidence String?
  disputeResolution String?

  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  paidAt       DateTime?
  completedAt  DateTime?
  processingAt DateTime?

  @@index([offerId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@index([createdAt])
  @@index([status, createdAt])
}

enum P2PTradeStatus {
  PENDING
  ESCROW_LOCKED
  PAID
  COMPLETED
  DISPUTED
  CANCELLED
  REFUNDED
}

// ============================================================================
// Business Grants
// ============================================================================

model GrantProposal {
  id               String   @id @default(uuid())

  businessName     String
  businessLocation String
  description      String   @db.Text
  requestedAmount  BigInt   // In USD cents
  videoUrl         String?

  applicantAddress String

  status           GrantStatus @default(VOTING)
  votesFor         Int         @default(0)
  votesAgainst     Int         @default(0)

  votingStartedAt  DateTime    @default(now())
  votingEndsAt     DateTime

  fundedAt         DateTime?
  fundingTx        String?     // Solana transaction signature

  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  votes            Vote[]
  updates          GrantUpdate[]

  @@index([status])
  @@index([applicantAddress])
  @@index([votingEndsAt])
}

enum GrantStatus {
  VOTING
  APPROVED
  REJECTED
  FUNDED
  COMPLETED
}

model Vote {
  id          String   @id @default(uuid())
  proposalId  String
  proposal    GrantProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  voterId     String
  voter       User     @relation(fields: [voterId], references: [id], onDelete: Cascade)

  weight      BigInt   // Based on staked MVGA
  direction   VoteDirection

  createdAt   DateTime @default(now())

  @@unique([proposalId, voterId])
  @@index([proposalId])
  @@index([voterId])
}

enum VoteDirection {
  FOR
  AGAINST
}

model GrantUpdate {
  id          String   @id @default(uuid())
  proposalId  String
  proposal    GrantProposal @relation(fields: [proposalId], references: [id], onDelete: Cascade)

  title       String
  content     String   @db.Text
  imageUrls   String[] @default([])

  createdAt   DateTime @default(now())

  @@index([proposalId])
}

// ============================================================================
// Referral System
// ============================================================================

model ReferralCode {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  code          String   @unique
  createdAt     DateTime @default(now())

  referrals     Referral[]

  @@index([walletAddress])
  @@index([code])
}

model Referral {
  id               String   @id @default(uuid())
  referrerAddress  String
  refereeAddress   String   @unique
  codeId           String
  code             ReferralCode @relation(fields: [codeId], references: [id])

  bonusPaid        Boolean  @default(false)
  bonusTxReferrer  String?
  bonusTxReferee   String?
  amount           Int      @default(100) // MVGA tokens

  createdAt        DateTime @default(now())

  @@index([referrerAddress])
  @@index([refereeAddress])
}

// ============================================================================
// Transaction Logging
// ============================================================================

model TransactionLog {
  id            String   @id @default(uuid())

  walletAddress String
  type          TransactionType

  signature     String   @unique // Solana transaction signature
  amount        BigInt?
  token         String?

  status        TransactionLogStatus @default(PENDING)
  error         String?

  createdAt     DateTime @default(now())
  confirmedAt   DateTime?

  @@index([walletAddress])
  @@index([type])
  @@index([signature])
  @@index([createdAt])
  @@index([confirmedAt])
  @@index([walletAddress, confirmedAt])
}

enum TransactionType {
  STAKE
  UNSTAKE
  P2P_ESCROW_LOCK
  P2P_ESCROW_RELEASE
  P2P_ESCROW_REFUND
  GRANT_FUNDING
  SWAP
  TRANSFER
  REFERRAL_BONUS
  BURN
  FEE_REWARD
}

enum TransactionLogStatus {
  PENDING
  CONFIRMED
  FAILED
}

// ============================================================================
// Treasury Distribution (Self-Sustaining Protocol)
// ============================================================================

model TreasuryDistribution {
  id               String   @id @default(uuid())

  // Distribution amounts
  totalAmount      BigInt   // Total collected this period
  burnAmount       BigInt   @default(0) // 5% burned
  liquidityAmount  BigInt   // 40% of distributable to Raydium LP
  stakingAmount    BigInt   // 40% of distributable to staking rewards vault
  grantsAmount     BigInt   // 20% of distributable to humanitarian fund

  // Transaction signatures
  burnTx           String?  // Burn transaction signature
  liquidityTx      String?  // Add liquidity tx
  stakingTx        String?  // Transfer to staking vault tx
  grantsTx         String?  // Transfer to grants treasury tx

  // Revenue sources breakdown
  swapFees         BigInt   @default(0)
  topupFees        BigInt   @default(0)
  giftcardFees     BigInt   @default(0)
  yieldEarnings    BigInt   @default(0)

  status           DistributionStatus @default(PENDING)
  periodStart      DateTime
  periodEnd        DateTime
  executedAt       DateTime?

  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  steps            DistributionStep[]

  @@index([status])
  @@index([periodEnd])
}

enum DistributionStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  FAILED
}

model TreasuryBalance {
  id               String   @id @default(uuid())

  // Wallet balances (in smallest units)
  mainWallet       BigInt   @default(0)  // Operating treasury
  liquidityWallet  BigInt   @default(0)  // LP reserves
  stakingWallet    BigInt   @default(0)  // Staking rewards vault
  grantsWallet     BigInt   @default(0)  // Humanitarian fund

  // Cumulative totals
  totalRevenue     BigInt   @default(0)
  totalDistributed BigInt   @default(0)
  totalToLiquidity BigInt   @default(0)
  totalToStaking   BigInt   @default(0)
  totalToGrants    BigInt   @default(0)

  // Snapshot timestamp
  snapshotAt       DateTime @default(now())

  @@index([snapshotAt])
}

model FeeCollection {
  id               String   @id @default(uuid())

  source           FeeSource
  amount           BigInt
  token            String    // USDC, SOL, MVGA
  signature        String?   @unique

  // Related transaction
  relatedTx        String?
  relatedType      String?   // swap, topup, giftcard, yield

  collected        Boolean   @default(false)
  collectedAt      DateTime?

  createdAt        DateTime  @default(now())

  @@index([source])
  @@index([collected])
  @@index([createdAt])
  @@index([collected, createdAt])
}

enum FeeSource {
  SWAP
  MOBILE_TOPUP
  GIFT_CARD
  YIELD
  P2P
}

// ============================================================================
// Token Burns (Deflationary Mechanism)
// ============================================================================

model TokenBurn {
  id        String     @id @default(uuid())
  amount    BigInt     // Amount burned in smallest units
  signature String     @unique // Solana transaction signature
  source    BurnSource // WEEKLY or MANUAL
  createdAt DateTime   @default(now())

  @@index([createdAt])
}

enum BurnSource {
  WEEKLY
  MANUAL
}

// ============================================================================
// Banking (Card Waitlist)
// ============================================================================

model CardWaitlist {
  id            String   @id @default(uuid())
  walletAddress String
  email         String?
  createdAt     DateTime @default(now())

  @@index([walletAddress])
}

// ============================================================================
// Fee Sharing (Staker Dividends)
// ============================================================================

model FeeSnapshot {
  id           String   @id @default(uuid())
  totalFees    BigInt   // Total fees allocated to stakers this period
  totalWeight  BigInt   // Sum of all stake weights at snapshot time
  feePerWeight Float    // Fees per unit of weight
  periodEnd    DateTime // End of the distribution period
  createdAt    DateTime @default(now())

  @@index([periodEnd])
}

// ============================================================================
// Protocol Metrics
// ============================================================================

model MetricsSnapshot {
  id           String   @id @default(uuid())
  tvl          BigInt   // Total value locked (staking + liquidity + escrow)
  volume24h    BigInt   // 24h transaction volume
  revenue24h   BigInt   // 24h fee revenue
  totalUsers   Int      // Total registered users
  activeUsers  Int      // Users active in last 24h
  totalStakers Int      // Users with active stakes
  totalBurned  BigInt   @default(0) // Cumulative tokens burned
  snapshotAt   DateTime @default(now())

  @@index([snapshotAt])
}

// ============================================================================
// Security Hardening (Auth, Locking, Auditing)
// ============================================================================

model AuthNonce {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  nonce         String
  expiresAt     DateTime
  used          Boolean  @default(false)
  createdAt     DateTime @default(now())

  @@index([expiresAt])
}

model StakingClaim {
  id         String   @id @default(uuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  amount     BigInt
  feeRewards BigInt   @default(0)
  signature  String   @unique
  claimedAt  DateTime @default(now())

  @@index([userId])
  @@index([claimedAt])
}

/// NOTE: A partial unique index exists in the database (managed by SQL migration):
/// CREATE UNIQUE INDEX "CronLock_jobName_active_idx" ON "CronLock"("jobName")
///     WHERE "completedAt" IS NULL;
/// This ensures only one active (non-completed) lock per job. Prisma cannot express
/// partial indexes, so do NOT use `prisma db push` â€” use `supabase db push` only.
model CronLock {
  id          String    @id @default(uuid())
  jobName     String
  lockedBy    String
  lockedAt    DateTime  @default(now())
  expiresAt   DateTime
  completedAt DateTime?

  @@index([jobName])
  @@index([expiresAt])
  @@index([jobName, completedAt])
}

model DistributionStep {
  id             String               @id @default(uuid())
  distributionId String
  distribution   TreasuryDistribution @relation(fields: [distributionId], references: [id], onDelete: Cascade)
  stepName       String
  status         String               @default("PENDING")
  signature      String?
  error          String?
  startedAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime             @default(now())

  @@unique([distributionId, stepName])
  @@index([distributionId])
}

model VaultReconciliation {
  id                 String   @id @default(uuid())
  vaultType          String   @default("STAKING")
  onChainBalance     BigInt
  dbSum              BigInt
  discrepancy        BigInt
  discrepancyPercent Float
  status             String   @default("OK")
  snapshotAt         DateTime @default(now())

  @@index([snapshotAt])
  @@index([status])
}

// ============================================================================
// Push Notifications
// ============================================================================

model PushSubscription {
  id            String   @id @default(uuid())
  walletAddress String
  endpoint      String   @unique
  p256dh        String   // Push encryption key
  auth          String   // Push auth secret
  userAgent     String?  // For multi-device debugging
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@index([walletAddress])
}

model NotificationPreference {
  id            String   @id @default(uuid())
  walletAddress String   @unique
  p2pTrades     Boolean  @default(true)
  staking       Boolean  @default(true)
  referrals     Boolean  @default(true)
  grants        Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

// ============================================================================
// Savings / Yield
// ============================================================================

model SavingsPosition {
  id              String        @id @default(uuid())
  walletAddress   String
  protocol        String        @default("KAMINO") // Future: MARGINFI, DRIFT
  token           String        @default("USDC")
  depositedAmount BigInt                           // Original deposit in smallest units
  currentAmount   BigInt                           // Current value including yield
  kTokenBalance   BigInt        @default(0)        // Kamino receipt tokens held
  status          SavingsStatus @default(ACTIVE)
  depositTx       String?       @unique
  withdrawTx      String?       @unique
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  @@index([walletAddress])
  @@index([status])
}

enum SavingsStatus {
  PENDING
  ACTIVE
  WITHDRAWING
  CLOSED
}

model YieldSnapshot {
  id            String   @id @default(uuid())
  protocol      String
  token         String
  supplyApy     Float              // Current supply APY from protocol
  totalDeposits BigInt             // Total MVGA user deposits in protocol
  totalYield    BigInt             // Cumulative yield earned
  snapshotAt    DateTime @default(now())

  @@index([protocol, token])
  @@index([snapshotAt])
}

// ============================================================================
// Card Applications (Lithic Integration)
// ============================================================================

model CardApplication {
  id            String        @id @default(uuid())
  walletAddress String
  provider      CardProvider  @default(NONE)
  lithicAccountHolderToken String? @unique
  lithicAccountToken       String? @unique
  lithicCardToken          String? @unique
  lithicFinancialAccountToken String?
  status        CardAppStatus @default(WAITLISTED)
  kycData       Json?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt

  @@index([walletAddress])
  @@index([status])
}

enum CardProvider {
  NONE
  LITHIC
}

enum CardAppStatus {
  WAITLISTED
  KYC_PENDING
  KYC_APPROVED
  KYC_REJECTED
  CARD_ISSUED
  FROZEN
}

// ============================================================================
// Payment Requests (Charge / Cobrar)
// ============================================================================

model PaymentRequest {
  id               String               @id @default(uuid())
  recipientAddress String
  token            String               // USDC, USDT, MVGA
  amount           BigInt               // In smallest units (6 or 9 decimals)
  memo             String?
  status           PaymentRequestStatus @default(PENDING)
  paymentTx        String?              @unique  // On-chain tx that paid this
  paypalOrderId    String?              @unique  // PayPal order ID if paid via PayPal
  paymentMethod    String?              // 'solana' | 'paypal'
  expiresAt        DateTime             // Default: 24h from creation
  createdAt        DateTime             @default(now())
  updatedAt        DateTime             @updatedAt

  @@index([recipientAddress])
  @@index([status])
  @@index([expiresAt])
}

enum PaymentRequestStatus {
  PENDING
  PAID
  EXPIRED
  CANCELLED
}

// ============================================================================
// Mobile Top-Ups (Reloadly)
// ============================================================================

model TopUp {
  id                String       @id @default(uuid())
  userId            String       // Wallet address of the sender
  recipientPhone    String       // Full phone number (e.g. 584121234567)
  countryCode       String       // ISO country code (VE)
  operatorId        Int          // Reloadly operator ID
  operatorName      String       // e.g. "Movistar Venezuela"
  amountUsd         Float        // Amount charged in USD
  deliveredAmount   Float?       // Amount delivered in local currency
  deliveredCurrency String?      // e.g. VES
  status            TopUpStatus  @default(PENDING)
  reloadlyTxId      String?      @unique // Reloadly transaction ID
  customIdentifier  String       @unique // Idempotency key
  errorMessage      String?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  @@index([userId])
  @@index([status])
}

enum TopUpStatus {
  PENDING
  SUCCESSFUL
  FAILED
  REFUNDED
}

// ============================================================================
// Gift Cards (Bitrefill)
// ============================================================================

model GiftCard {
  id               String         @id @default(uuid())
  walletAddress    String
  productId        String         // Bitrefill product slug
  productName      String         // e.g. "Amazon US $25"
  category         String?        // e.g. "shopping", "gaming", "streaming"
  amountUsd        Float
  code             String?        // Delivered gift card code
  pin              String?        // PIN if applicable
  status           GiftCardStatus @default(PENDING)
  bitrefillOrderId String?        @unique
  customIdentifier String         @unique // Idempotency key
  paymentSignature String?        // Solana tx signature
  errorMessage     String?
  createdAt        DateTime       @default(now())
  updatedAt        DateTime       @updatedAt

  @@index([walletAddress])
  @@index([status])
}

enum GiftCardStatus {
  PENDING
  DELIVERED
  FAILED
  CANCELLED
}

// ============================================================================
// Recurring Payments & DCA
// ============================================================================

enum RecurringFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
}

enum RecurringStatus {
  ACTIVE
  PAUSED
  CANCELLED
}

enum ScheduledType {
  PAYMENT
  DCA
}

enum ExecutionStatus {
  PENDING
  COMPLETED
  EXPIRED
  FAILED
  SKIPPED
}

model RecurringPayment {
  id               String              @id @default(uuid())
  walletAddress    String
  recipientAddress String
  recipientLabel   String?
  token            String              // SOL, USDC, USDT, MVGA
  amount           BigInt              // smallest units (lamports / 6-9 decimals)
  frequency        RecurringFrequency
  status           RecurringStatus     @default(ACTIVE)
  memo             String?
  nextExecutionAt  DateTime
  lastExecutedAt   DateTime?
  createdAt        DateTime            @default(now())
  updatedAt        DateTime            @updatedAt
  executions       ScheduledExecution[]

  @@index([walletAddress, status])
  @@index([status, nextExecutionAt])
}

model DCAOrder {
  id              String              @id @default(uuid())
  walletAddress   String
  inputToken      String              // Token to spend (USDC, SOL, etc.)
  outputToken     String              // Token to buy (SOL, MVGA, etc.)
  inputAmount     BigInt              // Amount to spend each cycle (smallest units)
  frequency       RecurringFrequency
  status          RecurringStatus     @default(ACTIVE)
  slippageBps     Int                 @default(50) // 0.5% default
  totalSpent      BigInt              @default(0)
  totalReceived   BigInt              @default(0)
  executionCount  Int                 @default(0)
  nextExecutionAt DateTime
  lastExecutedAt  DateTime?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime            @updatedAt
  executions      ScheduledExecution[]

  @@index([walletAddress, status])
  @@index([status, nextExecutionAt])
}

model ScheduledExecution {
  id           String            @id @default(uuid())
  type         ScheduledType
  paymentId    String?
  payment      RecurringPayment? @relation(fields: [paymentId], references: [id], onDelete: Cascade)
  dcaId        String?
  dca          DCAOrder?         @relation(fields: [dcaId], references: [id], onDelete: Cascade)
  status       ExecutionStatus   @default(PENDING)
  scheduledFor DateTime
  notifiedAt   DateTime?
  executedAt   DateTime?
  expiresAt    DateTime          // 24h after creation
  signature    String?           @unique
  inputAmount  BigInt?
  outputAmount BigInt?
  error        String?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt

  @@index([status, expiresAt])
  @@index([paymentId])
  @@index([dcaId])
}

// ============================================================================
// Airtm Off-Ramp Payouts
// ============================================================================

model Payout {
  id               String       @id @default(uuid())
  walletAddress    String       // Sender wallet
  recipientEmail   String       // Airtm recipient email
  amountUsd        Float        // Amount in USD
  description      String?      // Optional memo
  status           PayoutStatus @default(PENDING)
  airtmPayoutId    String?      @unique // Airtm payout ID
  airtmCode        String?      // Airtm reference code
  errorMessage     String?
  completedAt      DateTime?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  @@index([walletAddress])
  @@index([status])
}

enum PayoutStatus {
  PENDING
  COMMITTED
  PROCESSING
  COMPLETED
  CANCELLED
  FAILED
}

// ============================================================================
// MoneyGram Ramps (Stellar SEP-24 + Allbridge)
// ============================================================================

model MoneygramTransaction {
  id                   String             @id @default(uuid())
  walletAddress        String
  direction            MoneygramDirection
  amountUsd            Float
  status               MoneygramStatus    @default(INITIATED)

  // SEP-24 identifiers
  stellarTransactionId String?            @unique
  interactiveUrl       String?
  stellarMemo          String?
  stellarDestination   String?

  // Bridge tracking
  bridgeTxSolana       String?
  bridgeTxStellar      String?
  bridgeStatus         String?

  // MoneyGram details
  referenceNumber      String?
  pickupLocation       String?

  // Fees
  bridgeFeeUsd         Float?
  mgFeeUsd             Float?
  netAmountUsd         Float?

  // Error handling
  errorMessage         String?
  retryCount           Int                @default(0)
  lastPolledAt         DateTime?

  // Lifecycle
  confirmedAt          DateTime?
  completedAt          DateTime?
  cancelledAt          DateTime?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt

  @@index([walletAddress])
  @@index([status])
  @@index([status, lastPolledAt])
}

enum MoneygramDirection {
  ONRAMP
  OFFRAMP
}

enum MoneygramStatus {
  INITIATED
  PENDING_KYC
  CONFIRMED
  BRIDGING
  USDC_SENT
  PENDING_PICKUP
  PENDING_DEPOSIT
  USDC_RECEIVED
  BRIDGING_BACK
  COMPLETED
  FAILED
  CANCELLED
  EXPIRED
}

// ============================================================================
// Analytics Events
// ============================================================================

model AnalyticsEvent {
  id            String   @id @default(uuid())
  walletAddress String?
  event         String
  properties    Json?
  createdAt     DateTime @default(now())

  @@index([walletAddress])
  @@index([event])
  @@index([createdAt])
  @@index([event, createdAt])
}
